<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Live Tracker</title>
    <!-- Chargement de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuration de Tailwind pour un thème sombre et des couleurs NBA
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'espn-red': '#C8102E',
                        'dark-bg': '#0f172a',
                        'card-bg': '#1e293b',
                        'accent-yellow': '#FFC72C',
                        'gemini-blue': '#4285F4', // Couleur pour les fonctions IA
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; }
        .container-content { min-height: calc(100vh - 80px); }
        .team-card, .game-card { transition: all 0.2s ease-in-out; cursor: pointer; border-bottom: 4px solid transparent; }
        .team-card:hover { transform: translateY(-4px); box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3); border-bottom-color: #C8102E; }
        .loader { border: 4px solid rgba(255, 255, 255, 0.1); border-top: 4px solid #C8102E; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Style pour les boutons IA */
        .gemini-btn {
            background-color: #4285F4;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .gemini-btn:hover { background-color: #357ae8; }
        .gemini-loader {
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-top: 2px solid #fff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
    </style>
    <!-- Firebase Imports (Obligatoire pour l'environnement) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;
        window.isAuthReady = false;

        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        setLogLevel('Debug');

        const initializeFirebase = async () => {
            try {
                if (Object.keys(firebaseConfig).length > 0) {
                    window.firebaseApp = initializeApp(firebaseConfig);
                    window.db = getFirestore(window.firebaseApp);
                    window.auth = getAuth(window.firebaseApp);
                    await setPersistence(window.auth, browserSessionPersistence);
                    if (initialAuthToken) { await signInWithCustomToken(window.auth, initialAuthToken); } 
                    else { await signInAnonymously(window.auth); }
                    window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                    window.isAuthReady = true;
                } else {
                    console.warn("Firebase config not available.");
                    window.isAuthReady = true;
                }
                document.dispatchEvent(new CustomEvent('auth-ready'));
            } catch (error) {
                console.error("Erreur init Firebase:", error);
                window.isAuthReady = true;
                document.dispatchEvent(new CustomEvent('auth-ready'));
            }
        };
        initializeFirebase();
    </script>
</head>
<body class="bg-gray-900 text-white min-h-screen">

    <div id="app" class="flex flex-col min-h-screen">
        <!-- En-tête -->
        <header class="bg-gray-800 shadow-xl sticky top-0 z-10">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex flex-col sm:flex-row justify-between items-center">
                <h1 class="text-3xl font-extrabold text-white mb-2 sm:mb-0">
                    <span class="text-espn-red">NBA</span> Tracker <span class="text-sm font-light text-gray-400">| Saison 2025-26</span>
                </h1>
                <nav class="flex space-x-4">
                    <button id="tab-teams" class="nav-tab px-4 py-2 rounded-lg font-semibold text-white bg-espn-red/80 hover:bg-espn-red transition duration-150 shadow-md" data-view="teams">
                        Équipes & Joueurs
                    </button>
                    <button id="tab-scores" class="nav-tab px-4 py-2 rounded-lg font-semibold text-gray-300 hover:text-white hover:bg-card-bg transition duration-150" data-view="scores">
                        Scores en direct
                    </button>
                </nav>
            </div>
        </header>

        <!-- Contenu principal -->
        <main class="flex-grow p-4 sm:p-8 max-w-7xl mx-auto w-full container-content">
            <div id="loading" class="flex flex-col items-center justify-center py-20">
                <div class="loader"></div>
                <p class="mt-4 text-gray-400">Chargement des données NBA...</p>
            </div>

            <div id="api-error-message" class="hidden bg-espn-red/30 border-l-4 border-espn-red p-4 rounded-lg mb-8 text-sm" role="alert">
                <p class="font-bold text-white">Info API</p>
                <p class="text-gray-200">Impossible de charger certaines données via l'API publique. Veuillez vérifier votre connexion.</p>
            </div>

            <!-- Vue Équipes -->
            <div id="teams-view" class="view hidden">
                <h2 class="text-4xl font-bold mb-8 text-espn-red border-b-2 border-espn-red pb-2">Équipes NBA</h2>
                <div id="team-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"></div>
            </div>

            <!-- Vue Détail -->
            <div id="team-detail-view" class="view hidden">
                <button onclick="goBackToTeams()" class="mb-6 flex items-center text-espn-red hover:text-white transition duration-200">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    Retour aux équipes
                </button>
                <div id="team-header" class="bg-card-bg p-6 rounded-xl shadow-lg mb-6 flex flex-col md:flex-row md:items-center md:space-x-4">
                    <!-- Contenu inséré par renderTeamDetail -->
                </div>
                
                <!-- Section Analyse IA -->
                <div id="ai-analysis-container" class="bg-gray-700/50 p-4 rounded-xl shadow-inner mb-8 hidden">
                    <p class="text-gemini-blue font-bold mb-2">✨ Analyse de Performance par Gemini</p>
                    <div id="ai-analysis-content" class="text-sm text-gray-300"></div>
                </div>

                <h3 id="roster-heading" class="text-3xl font-semibold mb-6 text-gray-200">Effectif</h3>
                <div id="player-loading" class="flex flex-col items-center justify-center py-10"><div class="loader"></div></div>
                <div id="player-list" class="bg-card-bg rounded-xl shadow-lg overflow-hidden hidden"></div>

                <h3 id="schedule-heading" class="text-3xl font-semibold mb-6 mt-10 text-gray-200">Calendrier</h3>
                <div id="schedule-loading" class="flex flex-col items-center justify-center py-10"><div class="loader"></div></div>
                <div id="schedule-list" class="bg-card-bg rounded-xl shadow-lg overflow-hidden hidden"></div>
            </div>

            <!-- Vue Scores -->
            <div id="scores-view" class="view hidden">
                <h2 class="text-4xl font-bold mb-4 text-espn-red border-b-2 border-espn-red pb-2">Scores NBA</h2>
                <div class="flex justify-between items-center mb-6 bg-card-bg p-3 rounded-lg shadow-md">
                    <button id="prev-day-btn" class="text-white hover:text-espn-red p-2 rounded-full hover:bg-gray-700/50">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                    </button>
                    <p class="text-lg font-semibold text-white" id="scores-date-display">Chargement...</p>
                    <button id="next-day-btn" class="text-white hover:text-espn-red p-2 rounded-full hover:bg-gray-700/50">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </button>
                </div>
                <p class="text-gray-400 mb-4 text-sm" id="scores-update-info"></p>
                <div id="game-list" class="space-y-4"></div>
            </div>
        </main>

        <footer class="bg-gray-800 text-center p-4 text-sm text-gray-500 mt-8">
            <p>&copy; 2025 NBA Tracker. Propulsé par les données ESPN et l'IA de Gemini.</p>
        </footer>
    </div>

    <script>
        const BASE_URL_TEAMS = "https://site.api.espn.com/apis/site/v2/sports/basketball/nba";
        const BASE_URL_SCOREBOARD = "https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard";
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";
        const API_KEY = ""; // L'environnement de Canvas fournit la clé API si elle est laissée vide.
        
        const getEspnSeasonYear = () => {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + 1; 
            if (month < 10) return year; 
            return year + 1;
        };

        const CURRENT_NBA_SEASON_YEAR = getEspnSeasonYear(); 

        // --- Variables ---
        let currentView = 'teams';
        let allTeams = [];
        let liveScoresInterval = null;
        let teamsMap = {}; 
        let currentScoreDate = new Date();

        // --- DOM ---
        const loadingScreen = document.getElementById('loading');
        const apiErrorMessage = document.getElementById('api-error-message');
        const views = { teams: document.getElementById('teams-view'), detail: document.getElementById('team-detail-view'), scores: document.getElementById('scores-view') };
        const teamListContainer = document.getElementById('team-list');
        const gameListContainer = document.getElementById('game-list');
        const playerListContainer = document.getElementById('player-list');
        const playerLoading = document.getElementById('player-loading');
        const scheduleListContainer = document.getElementById('schedule-list');
        const scheduleLoading = document.getElementById('schedule-loading');
        const navTabs = document.querySelectorAll('.nav-tab');
        const aiAnalysisContainer = document.getElementById('ai-analysis-container');
        const aiAnalysisContent = document.getElementById('ai-analysis-content');

        // --- Utils ---
        const formatDateForDisplay = (date) => date.toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
        const getApiDateString = (date) => {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}${m}${d}`;
        }

        const handleApiRequest = async (url) => {
            try {
                const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error("API Error:", error);
                if (url.includes('/teams') && !url.includes('/roster')) apiErrorMessage.classList.remove('hidden');
                throw error;
            }
        };

        // --- Gemini API Call Function ---
        const callGeminiApi = async (userQuery, systemPrompt = "", useSearch = true) => {
            const apiUrl = `${GEMINI_API_URL}${API_KEY}`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            
            if (useSearch) {
                payload.tools = [{ "google_search": {} }];
            }

            for (let i = 0; i < 3; i++) { 
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.status === 429 && i < 2) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        console.warn(`Rate limit. Retrying in ${delay / 1000}s...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    }

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error(`Gemini API HTTP Error ${response.status}:`, errorBody);
                        // Retourne un message d'erreur plus spécifique en cas d'échec HTTP
                        return `Erreur API HTTP ${response.status}. Vérifiez votre clé API et les restrictions CORS/réseau.`;
                    }


                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (text) {
                        return text;
                    } else if (result.error) {
                         // Gère les erreurs renvoyées par l'API (ex: modèle non disponible)
                        return `Erreur Gemini: ${result.error.message}`;
                    } else {
                        // Cas où la réponse est OK, mais le texte est manquant
                        return "Réponse IA vide ou mal formée. Réessayez.";
                    }

                } catch (error) {
                    console.error(`Gemini API call failed (attempt ${i + 1}):`, error);
                    // Erreur réseau ou JSON parsing
                    return `Erreur réseau/parsing. Assurez-vous que l'URL de l'API est accessible.`;
                }
            }
            return "Échec de l'IA après plusieurs tentatives.";
        };

        // --- Fonctions d'Analyse IA ---

        /**
         * Génère une analyse de la performance de l'équipe par IA.
         */
        window.generateTeamAnalysis = async (teamName, teamLocation, record, conference) => {
            const button = document.getElementById('ai-analysis-btn');
            if (!button || button.disabled) return;

            button.disabled = true;
            button.innerHTML = '<span class="gemini-loader"></span> Analyse en cours...';
            aiAnalysisContainer.classList.remove('hidden');
            aiAnalysisContent.innerHTML = `<p class="italic text-gray-400">Recherche d'informations et analyse en cours...</p>`;

            const teamFullName = `${teamLocation} ${teamName}`;
            
            // NOTE: useSearch = true (par défaut) pour l'analyse d'équipe afin d'obtenir des données à jour.
            const systemPrompt = "Vous êtes un analyste sportif de la NBA. Fournissez une analyse concise (1 à 2 paragraphes, max 100 mots) et pertinente sur la performance actuelle de l'équipe. Basez-vous sur leur bilan, leur conférence, et les dernières nouvelles pour évaluer leur position (bonne/mauvaise saison, perspectives). Répondez en français.";
            const userQuery = `Analyse la performance actuelle de l'équipe NBA: ${teamFullName}. Leur bilan est ${record} en ${conference} Conference.`;
            
            const analysis = await callGeminiApi(userQuery, systemPrompt, true);

            aiAnalysisContent.innerHTML = analysis.replace(/\n/g, '<br>');
            button.disabled = false;
            button.innerHTML = '✨ Nouvelle Analyse IA';
        };

        /**
         * Génère une synthèse de match par IA.
         */
        window.generateMatchSummary = async (matchId, homeTeam, awayTeam, score, status) => {
            const button = document.getElementById(`summary-btn-${matchId}`);
            const summaryDiv = document.getElementById(`summary-content-${matchId}`);
            
            if (!button || button.disabled) return;

            button.disabled = true;
            button.innerHTML = '<span class="gemini-loader"></span> Synthèse...';
            summaryDiv.innerHTML = `<p class="italic text-xs text-gray-400 mt-2">Génération de la synthèse du match...</p>`;

            // NOTE: useSearch = false pour la synthèse de match
            const systemPrompt = "Vous êtes un commentateur sportif. Rédigez un court résumé de match (1 phrase) sur la rencontre NBA entre l'équipe à domicile et l'équipe extérieure. Mentionnez le score final et le contexte (victoire serrée, écrasante, etc.). Répondez en français.";
            const userQuery = `Match terminé : ${awayTeam} vs ${homeTeam}. Score final : ${score}. Résume ce match.`;

            const summary = await callGeminiApi(userQuery, systemPrompt, false);

            if (summary.startsWith('Erreur') || summary.startsWith('Échec') || summary.includes('indisponible')) {
                summaryDiv.innerHTML = `<p class="text-sm mt-2 text-red-400 font-medium">${summary}</p>`;
            } else {
                summaryDiv.innerHTML = `<p class="text-sm mt-2 text-gray-300">${summary}</p>`;
                button.style.display = 'none'; // Cacher le bouton après la génération réussie
            }

            button.disabled = false;
            if (button.style.display !== 'none') {
                 button.innerHTML = '✨ Synthèse IA du Match';
            }
            summaryDiv.classList.remove('hidden');
        };


        // --- Data Fetching (Non-AI) ---
        
        const fetchStandings = async () => {
            try {
                const data = await handleApiRequest(`${BASE_URL_TEAMS}/standings`);
                const records = {};
                
                const findEntries = (obj) => {
                    let entries = [];
                    if (!obj) return [];
                    if (obj.entries) entries = entries.concat(obj.entries); 
                    if (obj.standings && obj.standings.entries) entries = entries.concat(obj.standings.entries);
                    if (obj.children) {
                        obj.children.forEach(child => { entries = entries.concat(findEntries(child)); });
                    }
                    if (obj.groups) {
                        obj.groups.forEach(group => { entries = entries.concat(findEntries(group)); });
                    }
                    return entries;
                };

                const entries = findEntries(data);
                
                entries.forEach(entry => {
                    if (entry && entry.team && entry.team.id) {
                        const teamId = String(entry.team.id);
                        let recordText = "N/A"; 

                        if (entry.summary && entry.summary.length > 0) {
                            recordText = entry.summary;
                        } 
                        else if (entry.stats) {
                            const getStatValue = (name) => {
                                const stat = entry.stats.find(s => 
                                    s.name === name || 
                                    s.type === name || 
                                    (name === 'wins' && (s.id === '10' || s.abbreviation === 'W')) ||
                                    (name === 'losses' && (s.id === '11' || s.abbreviation === 'L'))
                                );
                                return stat ? (stat.displayValue !== undefined ? stat.displayValue : stat.value) : undefined;
                            };
                            
                            const wins = getStatValue('wins');
                            const losses = getStatValue('losses');
                            
                            if (wins !== undefined && losses !== undefined) {
                                recordText = `${wins}-${losses}`;
                            }
                        }

                        if (recordText !== "N/A") {
                             records[teamId] = recordText;
                        }
                    }
                });
                
                return records;
            } catch (e) {
                console.error("Standings fetch error:", e);
                return {}; 
            }
        };

        const fetchTeams = async () => {
            const [teamsData, standingsData] = await Promise.all([
                handleApiRequest(`${BASE_URL_TEAMS}/teams`),
                fetchStandings()
            ]);
            
            const teams = teamsData.sports[0].leagues[0].teams;

            const formattedTeams = teams.map(item => {
                const t = item.team;
                const record = standingsData[String(t.id)] || "N/A";

                return {
                    id: t.id, 
                    name: t.name, 
                    location: t.location, 
                    abbreviation: t.abbreviation,
                    logoUrl: t.logos ? t.logos[0].href : '',
                    conference: t.standingSummary?.includes('East') ? 'Est' : 'Ouest',
                    division: t.standings?.division || 'N/A',
                    record: record 
                };
            });

            teamsMap = formattedTeams.reduce((acc, t) => ({ ...acc, [t.abbreviation]: t, [t.id]: t }), {});
            return formattedTeams;
        };

        const fetchTeamRoster = async (abbr) => {
            const data = await handleApiRequest(`${BASE_URL_TEAMS}/teams/${abbr}/roster`);
            if (!data.athletes) return [];
            return data.athletes.map(p => ({
                name: p.displayName, number: p.jersey || '?',
                position: p.position?.displayName || 'N/A', age: p.age || 'N/A'
            }));
        };

        const fetchTeamSchedule = async (teamAbbreviation) => {
            const url = `${BASE_URL_TEAMS}/teams/${teamAbbreviation}/schedule?season=${CURRENT_NBA_SEASON_YEAR}&seasontype=2`; 
            const data = await handleApiRequest(url);

            if (!data.events) {
                return [];
            }
            // Code pour le calendrier (similaire à la version précédente)
            return data.events.map(event => {
                const competition = event.competitions[0];
                const date = new Date(event.date);

                const rawStatus = competition?.status?.type?.name || "UNKNOWN";
                let status = "Date/Statut non confirmé";

                if (rawStatus === "STATUS_FINAL" || competition.status?.type?.completed) {
                    const home = competition.competitors.find(c => c.homeAway === "home");
                    const away = competition.competitors.find(c => c.homeAway === "away");
                    const getVal = (s) => (s && typeof s === 'object' && s.value !== undefined) ? parseInt(s.value) : parseInt(s || 0);
                    const homeScore = getVal(home.score);
                    const awayScore = getVal(away.score);
                    let winnerTeam = homeScore > awayScore ? home.team.displayName : (awayScore > homeScore ? away.team.displayName : "Égalité");
                    status = `Final : ${homeScore}-${awayScore}<br><span class="text-gray-400 text-[10px]">Vainqueur: ${winnerTeam}</span>`;
                } else if (rawStatus === "STATUS_IN_PROGRESS") {
                    const clock = competition.status.displayClock || "";
                    status = `En cours – ${clock}`;
                } else if (rawStatus === "STATUS_SCHEDULED") {
                    status = date.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" });
                } else if (rawStatus === "STATUS_POSTPONED") {
                    status = "Reporté";
                }

                const home = competition.competitors.find(c => c.homeAway === 'home');
                const away = competition.competitors.find(c => c.homeAway === 'away');
                const isHome = home.team.abbreviation === teamAbbreviation;
                const opponent = isHome ? away : home;
                const location = isHome ? 'vs' : '@';

                let score = '';
                let winLoss = '';

                if (competition.status?.type?.completed) {
                    const getVal = (s) => (s && typeof s === 'object' && s.value !== undefined) ? parseInt(s.value) : parseInt(s || 0);
                    const teamObj = competition.competitors.find(c => c.team.abbreviation === teamAbbreviation);
                    const teamScore = getVal(teamObj?.score);
                    const oppScore = getVal(opponent.score);
                    score = `${teamScore}-${oppScore}`;
                    winLoss = teamScore > oppScore ? 'G' : teamScore < oppScore ? 'P' : '';
                }

                return {
                    date: formatDateForDisplay(date), opponent: opponent.team.displayName, location: location,
                    score: score, status: status, winLoss: winLoss
                };
            });
        };

        const fetchLiveScores = async (date) => {
            const apiDate = getApiDateString(date);
            document.getElementById('scores-date-display').textContent = formatDateForDisplay(date);
            const data = await handleApiRequest(`${BASE_URL_SCOREBOARD}?dates=${apiDate}`);
            if (!data.events) return [];

            return data.events.map(evt => {
                const comp = evt.competitions[0];
                const home = comp.competitors.find(c => c.homeAway === 'home');
                const away = comp.competitors.find(c => c.homeAway === 'away');
                const isFinal = evt.status.type.completed;
                
                let statusText = isFinal ? 'FINAL' : (evt.status.type.state === 'in' ? `Live (Q${evt.status.period}, ${evt.status.displayClock})` : evt.status.type.detail);

                return {
                    id: evt.id,
                    homeTeam: home.team.displayName, awayTeam: away.team.displayName,
                    homeScore: home.score || '0', awayScore: away.score || '0',
                    homeAbbr: home.team.abbreviation, awayAbbr: away.team.abbreviation,
                    status: statusText, isFinal
                };
            });
        };

        // --- Rendu ---
        const setView = (name) => {
            currentView = name;
            Object.values(views).forEach(v => v.classList.add('hidden'));
            if (views[name]) views[name].classList.remove('hidden');
            
            navTabs.forEach(tab => {
                const isActive = tab.getAttribute('data-view') === name;
                tab.className = isActive 
                    ? 'nav-tab px-4 py-2 rounded-lg font-semibold text-white bg-espn-red/80 hover:bg-espn-red transition duration-150 shadow-md'
                    : 'nav-tab px-4 py-2 rounded-lg font-semibold text-gray-300 hover:text-white hover:bg-card-bg transition';
            });

            if (name === 'scores') {
                if (!liveScoresInterval) {
                    currentScoreDate = new Date();
                    renderLiveScores();
                    liveScoresInterval = setInterval(() => renderLiveScores(), 10000);
                }
            } else {
                if (liveScoresInterval) { clearInterval(liveScoresInterval); liveScoresInterval = null; }
            }
        };

        window.goBackToTeams = () => { setView('teams'); document.getElementById('tab-teams').click(); };

        const renderTeams = () => {
            teamListContainer.innerHTML = '';
            allTeams.forEach(team => {
                const card = document.createElement('div');
                card.className = 'team-card bg-card-bg rounded-xl p-6 shadow-2xl flex flex-col items-center hover:bg-gray-700/50';
                card.onclick = () => renderTeamDetail(team.abbreviation);
                card.innerHTML = `
                    <img src="${team.logoUrl}" onerror="this.src='https://placehold.co/100x100/6b7280/ffffff?text=${team.abbreviation}'" class="w-20 h-20 mb-4 object-contain">
                    <h3 class="text-xl font-bold text-white text-center">${team.location} <span class="text-espn-red block">${team.name}</span></h3>
                    <div class="mt-auto pt-3 w-full flex justify-between items-center border-t border-gray-600 text-xs text-gray-400">
                        <span>${team.conference}</span>
                        <span class="bg-gray-700 text-white px-2 py-1 rounded font-bold">Bilan: ${team.record}</span>
                    </div>
                `;
                teamListContainer.appendChild(card);
            });
        };

        const renderTeamDetail = async (abbr) => {
            const team = allTeams.find(t => t.abbreviation === abbr);
            if (!team) return;

            const displaySeason = `${CURRENT_NBA_SEASON_YEAR - 1}-${CURRENT_NBA_SEASON_YEAR}`;
            document.getElementById('roster-heading').textContent = `Effectif (Roster) - Saison ${displaySeason}`;
            document.getElementById('schedule-heading').textContent = `Calendrier - Saison ${displaySeason}`;

            // Mise à jour de l'en-tête de l'équipe avec le bouton IA
            document.getElementById('team-header').innerHTML = `
                <img src="${team.logoUrl}" onerror="this.src='https://placehold.co/100x100/6b7280/ffffff?text=${team.abbreviation}'" class="w-24 h-24 object-contain">
                <div class="flex-1 min-w-0 mt-4 md:mt-0">
                    <h2 class="text-3xl font-bold text-white">${team.location} <span class="text-accent-yellow">${team.name}</span></h2>
                    <p class="text-gray-400">${team.conference} | ${team.division}</p>
                    <div class="flex flex-col sm:flex-row sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mt-2">
                        <p class="text-lg font-bold text-white bg-espn-red/20 inline-block px-3 py-1 rounded border border-espn-red">Bilan Saison: ${team.record}</p>
                        <button id="ai-analysis-btn" onclick="generateTeamAnalysis('${team.name}', '${team.location}', '${team.record}', '${team.conference}')" class="gemini-btn flex items-center justify-center text-sm">
                            ✨ Analyse IA de la Performance
                        </button>
                    </div>
                </div>
            `;
            
            // Réinitialiser la section d'analyse
            aiAnalysisContainer.classList.add('hidden');
            aiAnalysisContent.innerHTML = '';


            playerListContainer.classList.add('hidden'); playerLoading.classList.remove('hidden');
            scheduleListContainer.classList.add('hidden'); scheduleLoading.classList.remove('hidden');
            setView('detail');

            try {
                const players = await fetchTeamRoster(abbr);
                // Rendu de l'effectif (similaire à la version précédente)
                playerListContainer.innerHTML = `
                    <div class="grid grid-cols-4 text-sm font-bold text-gray-300 bg-gray-800 p-3">
                        <div>#</div><div class="col-span-2">Nom</div><div>Pos</div>
                    </div>
                `;
                if (players.length === 0) playerListContainer.innerHTML += '<p class="p-4 text-center text-gray-400">Aucun joueur trouvé.</p>';
                players.forEach((p, i) => {
                    playerListContainer.innerHTML += `
                        <div class="grid grid-cols-4 p-3 border-b border-gray-700 ${i % 2 === 0 ? 'bg-card-bg' : 'bg-gray-800'}">
                            <div class="text-espn-red font-mono">${p.number}</div>
                            <div class="col-span-2 text-white">${p.name}</div>
                            <div class="text-gray-400">${p.position}</div>
                        </div>
                    `;
                });
                playerLoading.classList.add('hidden'); playerListContainer.classList.remove('hidden');

                const schedule = await fetchTeamSchedule(abbr);
                // Rendu du calendrier (similaire à la version précédente)
                scheduleListContainer.innerHTML = `
                    <div class="grid grid-cols-6 text-sm font-bold text-gray-300 bg-gray-800 p-3">
                        <div class="col-span-2">Date</div>
                        <div class="text-center">Lieu</div>
                        <div class="col-span-2">Adversaire</div>
                        <div class="text-right">Résultat</div>
                    </div>
                `;
                if (schedule.length === 0) scheduleListContainer.innerHTML += '<p class="p-4 text-center text-gray-400">Aucun match trouvé.</p>';
                schedule.forEach((g, i) => {
                    const color = g.winLoss === 'G' ? 'text-green-400' : (g.winLoss === 'P' ? 'text-red-400' : 'text-gray-400');
                    const displayResult = g.score ? `${g.winLoss} ${g.score}` : g.status;
                    scheduleListContainer.innerHTML += `
                        <div class="grid grid-cols-6 p-3 border-b border-gray-700 ${i % 2 === 0 ? 'bg-card-bg' : 'bg-gray-800'} items-center">
                            <div class="col-span-2 text-gray-300 text-xs">${g.date}</div>
                            <div class="text-center font-bold ${g.location === 'vs' ? 'text-espn-red' : 'text-accent-yellow'}">${g.location}</div>
                            <div class="col-span-2 text-white text-sm truncate" title="${g.opponent}">${g.opponent}</div>
                            <div class="text-right text-xs font-bold ${color}">${displayResult}</div>
                        </div>
                    `;
                });
                scheduleLoading.classList.add('hidden'); scheduleListContainer.classList.remove('hidden');

            } catch (e) {
                console.error(e);
                playerListContainer.innerHTML = '<p class="p-4 text-red-400">Erreur chargement.</p>';
                playerLoading.classList.add('hidden'); playerListContainer.classList.remove('hidden');
                scheduleLoading.classList.add('hidden');
            }
        };

        const renderLiveScores = async () => {
            const gameList = document.getElementById('game-list');
            gameList.innerHTML = '';
            try {
                const games = await fetchLiveScores(currentScoreDate);
                if (games.length === 0) {
                    gameList.innerHTML = '<p class="text-center text-gray-400">Aucun match programmé pour cette date.</p>';
                    return;
                }
                games.forEach(g => {
                    const homeWin = parseInt(g.homeScore) > parseInt(g.awayScore) && g.isFinal;
                    const awayWin = parseInt(g.awayScore) > parseInt(g.homeScore) && g.isFinal;
                    
                    // Concaténer le nom de l'équipe et le score pour le résumé IA
                    const fullScore = `${g.awayTeam} ${g.awayScore} - ${g.homeTeam} ${g.homeScore}`;

                    // Bouton IA conditionnel
                    let iaButtonHtml = '';
                    let summaryDivHtml = `<div id="summary-content-${g.id}" class="hidden"></div>`;

                    if (g.isFinal) {
                        iaButtonHtml = `
                            <button id="summary-btn-${g.id}" onclick="generateMatchSummary('${g.id}', '${g.homeTeam}', '${g.awayTeam}', '${fullScore}', '${g.status}')" class="gemini-btn text-xs mt-3 flex items-center justify-center">
                                ✨ Synthèse IA du Match
                            </button>
                        `;
                    }

                    gameList.innerHTML += `
                        <div class="bg-card-bg p-4 rounded-xl border-l-4 ${g.isFinal ? 'border-gray-600' : 'border-espn-red'} shadow-lg">
                            <div class="flex justify-between text-xs text-gray-400 mb-2">
                                <span>${g.status}</span>
                            </div>
                            <div class="flex justify-between items-center mb-1">
                                <div class="flex items-center space-x-2">
                                    <img src="${teamsMap[g.awayAbbr]?.logoUrl || ''}" class="w-6 h-6">
                                    <span class="${awayWin ? 'text-accent-yellow font-bold' : 'text-white'}">${g.awayTeam}</span>
                                </div>
                                <span class="text-xl font-bold ${awayWin ? 'text-accent-yellow' : 'text-white'}">${g.awayScore}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <div class="flex items-center space-x-2">
                                    <img src="${teamsMap[g.homeAbbr]?.logoUrl || ''}" class="w-6 h-6">
                                    <span class="${homeWin ? 'text-accent-yellow font-bold' : 'text-white'}">${g.homeTeam}</span>
                                </div>
                                <span class="text-xl font-bold ${homeWin ? 'text-accent-yellow' : 'text-white'}">${g.homeScore}</span>
                            </div>
                            ${iaButtonHtml}
                            ${summaryDivHtml}
                        </div>
                    `;
                });
            } catch (e) { console.error(e); }
        };

        const changeScoreDate = (d) => {
            if (liveScoresInterval) { clearInterval(liveScoresInterval); liveScoresInterval = null; }
            currentScoreDate.setDate(currentScoreDate.getDate() + d);
            const today = new Date();
            // Redémarrer l'intervalle si on revient à la date d'aujourd'hui
            if (currentScoreDate.toDateString() === today.toDateString()) liveScoresInterval = setInterval(() => renderLiveScores(), 10000);
            renderLiveScores();
        };

        // Init
        const initApp = async () => {
            loadingScreen.classList.remove('hidden');
            try {
                allTeams = await fetchTeams();
                renderTeams();
                loadingScreen.classList.add('hidden');
                setView('teams');
            } catch (e) {
                console.error(e);
                loadingScreen.innerHTML = '<p class="text-red-500">Erreur fatale. Les données de l\'API ESPN ne sont pas disponibles.</p>';
            }
            
            document.getElementById('prev-day-btn').addEventListener('click', () => changeScoreDate(-1));
            document.getElementById('next-day-btn').addEventListener('click', () => changeScoreDate(1));
            navTabs.forEach(tab => tab.addEventListener('click', () => setView(tab.getAttribute('data-view'))));
        };

        if (window.isAuthReady) initApp();
        else document.addEventListener('auth-ready', initApp);

    </script>
</body>
</html>